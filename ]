import { Node } from '@tiptap/core';
import { mergeAttributes } from '@tiptap/core';
import { Text } from '@tiptap/extension-text';
import { EditorProvider, Extension } from '@tiptap/react';
import './index.css';
import { Editor } from '@tiptap/core';
import { findParentDomRefOfType } from 'prosemirror-utils';
import { Fragment, ResolvedPos } from '@tiptap/pm/model';
import { EditorState, Transaction } from '@tiptap/pm/state';
import { EditorView } from '@tiptap/pm/view';
import { Node as NodePM } from '@tiptap/pm/model'

const Doc = Node.create({
	name: 'document',
	topNode: true,
	content: 'page+',
});

const Page = Node.create({
  name: 'page',

  priority: 1000,

  addOptions() {
    return {
      HTMLAttributes: {
				class: 'page',
			},
    }
  },

  group: 'page',
  content: 'body',

  parseHTML() {
    return [
      { 
				tag: 'div' ,
				attrs: {
					class: "page",
				}
			},
    ]
  },

  renderHTML({ HTMLAttributes }) {
    return ['div', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]
  },
});

const Body = Node.create({
  name: 'body',

  priority: 1000,

  addOptions() {
    return {
      HTMLAttributes: {
				class: 'page-body',
			},
    }
  },

  group: 'body',
  content: 'block*',

  parseHTML() {
    return [
      { 
				tag: 'div' ,
				attrs: {
					class: "page-body",
				}
			},
    ]
  },

  renderHTML({ HTMLAttributes }) {
    return ['div', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]
  },
});

const Paragraph = Node.create({
  name: 'paragraph',

  priority: 1000,

  addOptions() {
    return {
      HTMLAttributes: {},
    }
  },

  group: 'block',
  content: 'inline*',

  parseHTML() {
    return [
      { tag: 'p' },
    ]
  },

  renderHTML({ HTMLAttributes }) {
    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]
  },
});

interface FontData {
	weight: string;
	size: string;
	family: string;
}

function getStyle(element: HTMLElement, prop: string) {
	return window.getComputedStyle(element).getPropertyValue(prop);
}

class TextMeasurer {
	canvas: HTMLCanvasElement;
	ctx: CanvasRenderingContext2D;

	paragraph: FontData;

	constructor(
		bounds: DOMRect,
	) {
		this.canvas = document.createElement('canvas');
		this.canvas.width = bounds.width;
		this.canvas.height = bounds.height;

		const ctx = this.canvas.getContext('2d');
		if (!ctx) throw new Error('Failed to get 2d context');
		this.ctx = ctx;

		this.paragraph = {
			weight: getStyle(this.canvas, 'font-weight'),
			size: getStyle(this.canvas, 'font-size'),
			family: getStyle(this.canvas, 'font-family'),
		};
	}

	getParagraphMetrics(text: string): TextMetrics {
		const { weight, size, family } = this.paragraph;
		this.ctx.font = `${weight} ${size} ${family}`;
		return this.ctx.measureText(text);
	}
}

class Paginator {
	bodyDimensions: DOMRect;

	constructor(
		public view: EditorView,
		public state: EditorState,
		body: HTMLElement,
	) {
		const rect = body.getBoundingClientRect();
		this.bodyDimensions = rect;
	}

	public joinDocument(tr: Transaction): Transaction {
		while (tr.doc.childCount > 1) {
			if (tr.doc.firstChild) tr.join(tr.doc.firstChild.nodeSize, 2);
		}
		return tr;
	}

	public splitDocument(tr: Transaction, split?: ResolvedPos): Transaction {
		if (!split) {
			const s = this.getSplitPos(tr.doc);
			if (!s) return tr;
			split = s;
		}

		let newTransaction = this.splitPage(tr, split);

		const after = this.getSplitPos(newTransaction.doc);
		if (after) {
			return this.splitDocument(newTransaction, after);
		}

		return newTransaction;
	}

	private splitPage(tr: Transaction, $pos: ResolvedPos): Transaction {
		const { pos, depth } = $pos;

		const paragraph = $pos.doc.nodeAt(pos);
		if (!paragraph) return tr;

		const bodyOfPage = $pos.node(depth);
		const paragraphs: NodePM[] = [];
		bodyOfPage.forEach((node, nodePos) => {
			if (nodePos >= $pos.parentOffset) {
				paragraphs.push(node);
			}
		});

		const body = $pos.node(depth).copy(Fragment.from(paragraphs));
		const page = this.state.schema.nodes['page'].create(null, body);

		const end = $pos.doc.resolve(0).end();
		return tr.replaceWith(pos, end, page);
	}

	private getSplitPos(doc: NodePM): ResolvedPos | null {
		let split!: ResolvedPos;
		let height = 0;

		const lastChild = doc.lastChild;
		if (!lastChild) return null;

		console.log("SEARCHING FOR SPLIT POS....");

		doc.descendants((node, pos) => {
			if (height > this.bodyDimensions.height) {
				return false;
			}

			const type = node.type.name;

			if (type === 'page' && node !== lastChild) {
				return false;
			}

			if (type === 'paragraph') {
				const viewNode = this.view.nodeDOM(pos);
				if (viewNode) {
					const element = viewNode as HTMLElement;

					let dh = 0;
					if (element.getBoundingClientRect) {
					  const rect = element.getBoundingClientRect();
					  dh = rect.height;
					} else {
						dh = 20;
					}

					height += dh;

					if (height > this.bodyDimensions.height) {
						console.log("FOUND SPLIT POS: ", element.innerText);
						split = doc.resolve(pos);
					}
				}
				return false;
			}

			return true;
		});

		return split ? split : null;
	}
}

const isOverflown = ({ clientWidth, clientHeight, scrollWidth, scrollHeight }: HTMLElement) => {
  return scrollHeight > clientHeight || scrollWidth > clientWidth
}

const Paging: Extension = Extension.create({
	name: 'paging',
	// @ts-ignore
  onUpdate({ editor }: { editor: Editor }): void {
		const { schema, selection, tr } = editor.state;

		const domAtPos = editor.view.domAtPos.bind(editor.view);
		const bodyDOM = findParentDomRefOfType(schema.nodes['body'], domAtPos)(selection);
		const bodyElement = bodyDOM as HTMLElement;

		if (isOverflown(bodyElement)) {
			const paginator = new Paginator(editor.view, editor.state, bodyElement);
			let newTransaction = tr;
			newTransaction = paginator.joinDocument(newTransaction);
			newTransaction = paginator.splitDocument(newTransaction);
			newTransaction = newTransaction.scrollIntoView();
			const state = editor.state.apply(newTransaction);
			editor.view.updateState(state);
		}
	},
})

const extensions = [
	Paging,
	Doc,
	Page,
	Body,
	Paragraph,
	Text,
];

function MyEditor() {
	return (
		<EditorProvider 
			extensions={extensions} 
			autofocus={true} 
			editable={true}
			content="<p>Hello World</p>">
			<span>Whatsapp</span>
		</EditorProvider>
	);
}

export function App() {
	return <main><MyEditor /></main>;
}
